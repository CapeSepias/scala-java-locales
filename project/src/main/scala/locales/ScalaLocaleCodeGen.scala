package locales

import java.io.{File, FileInputStream, InputStreamReader}
import java.nio.charset.Charset
import java.nio.file.Files
import java.text.SimpleDateFormat
import java.util.{Date, TimeZone}
import java.util.function.IntPredicate
import javax.xml.parsers.SAXParserFactory
import scala.collection.JavaConverters._
import scala.collection.breakOut
import scala.xml.{XML, _}

/**
 * Value objects build out of CLDR XML data
 */
case class Calendar(id: String) {
  val scalaSafeName: String = id.replace("-", "_")
}

case class MonthSymbols(months: Seq[String], shortMonths: Seq[String])
object MonthSymbols {
  val zero = MonthSymbols(Seq.empty, Seq.empty)
}

case class WeekdaysSymbols(weekdays: Seq[String], shortWeekdays: Seq[String])
object WeekdaysSymbols {
  val zero = WeekdaysSymbols(Seq.empty, Seq.empty)
}

case class AmPmSymbols(amPm: Seq[String])
object AmPmSymbols {
  val zero = AmPmSymbols(Seq.empty)
}

case class EraSymbols(eras: Seq[String])
object EraSymbols {
  val zero = EraSymbols(Seq.empty)
}

case class CalendarSymbols(months: MonthSymbols, weekdays: WeekdaysSymbols,
                           amPm: AmPmSymbols, eras: EraSymbols)

case class DateTimePattern(patternType: String, pattern: String)

case class CalendarPatterns(datePatterns: List[DateTimePattern], timePatterns: List[DateTimePattern])

object CalendarPatterns {
  val zero = CalendarPatterns(Nil, Nil)
}

case class NumericSystem(id: String, digits: String)

case class NumberSymbols(system: NumericSystem,
                         aliasOf: Option[NumericSystem] = None,
                         decimal: Option[Char] = None,
                         group: Option[Char] = None,
                         list: Option[Char] = None,
                         percent: Option[Char] = None,
                         plus: Option[Char] = None,
                         minus: Option[Char] = None,
                         perMille: Option[Char] = None,
                         infinity: Option[String] = None,
                         nan: Option[String] = None,
                         exp: Option[String] = None)

object NumberSymbols {
  def alias(system: NumericSystem, aliasOf: NumericSystem): NumberSymbols =
    NumberSymbols(system, aliasOf = Some(aliasOf))
}

// http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies
case class CurrencyDisplayName(name: String, count: Option[String])
case class CurrencySymbol(symbol: String, alt: Option[String])

case class NumberCurrency(currencyCode: String,
                          symbols: Seq[CurrencySymbol],
                          displayNames: Seq[CurrencyDisplayName])

// CurrencyData in supplemental/supplementalData.xml that defines currency availability by region
//    and digits/formatting, augment with Numeric Code Mappings & Master Currency Code List
case class CurrencyData(currencyTypes: Seq[CurrencyType],
                        fractions: Seq[CurrencyDataFractionsInfo],
                        regions: Seq[CurrencyDataRegion],
                        numericCodes: Seq[CurrencyNumericCode])

case class CurrencyType(currencyCode: String, currencyName: String)

case class CurrencyNumericCode(currencyCode: String, numericCode: Int)

case class CurrencyDataFractionsInfo(currencyCode: String, digits: Int, rounding: Int,
                                     cashDigits: Option[Int], cashRounding: Option[Int])

case class CurrencyDataRegion(countryCode: String, currencies: Seq[CurrencyDataRegionCurrency])

case class CurrencyDataRegionCurrency(currencyCode: String,
                                      from: Option[String], to: Option[String], tender: Option[Boolean])

case class XMLLDMLLocale(language: String, territory: Option[String],
                         variant: Option[String], script: Option[String])

case class XMLLDML(locale: XMLLDMLLocale, fileName: String, defaultNS: Option[NumericSystem],
                   digitSymbols: Map[NumericSystem, NumberSymbols], calendar: Option[CalendarSymbols],
                   datePatterns: Option[CalendarPatterns], currencies: Seq[NumberCurrency]) {

  val scalaSafeName: String = {
    List(Some(locale.language), locale.script, locale.territory, locale.variant)
      .flatten.mkString("_")
  }
}

object CodeGenerator {
  import treehugger.forest._
  import definitions._
  import treehuggerDSL._

  val autoGeneratedCommend = "Auto-generated code from CLDR definitions, don't edit"

  def buildClassTree(packageObject: String, ldmls: List[XMLLDML],
                     only: List[String], parentLocales: Map[String, List[String]]): Tree = {
    val langs = ldmls.map(_.scalaSafeName.split("_").toList)
    // Root must always be available
    val root = ldmls.find(_.scalaSafeName == "root").get

    val objectBlock = if (only.nonEmpty) {
      ldmls.filter(a => only.contains(a.scalaSafeName))
        .map(buildClassTree(root, langs, parentLocales))
    } else {
      ldmls.map(buildClassTree(root, langs, parentLocales))
    }

    BLOCK (
      List(IMPORT(REF("locales.cldr.LDML")) withComment autoGeneratedCommend,
        IMPORT(REF("locales.cldr.LDMLLocale")),
        IMPORT(REF("locales.cldr.Symbols")),
        IMPORT(REF("locales.cldr.CalendarSymbols")),
        IMPORT(REF("locales.cldr.CalendarPatterns")),
        IMPORT(REF("locales.cldr.NumberCurrency")),
        IMPORT(REF("locales.cldr.CurrencySymbol")),
        IMPORT(REF("locales.cldr.CurrencyDisplayName")),
        IMPORT(REF("locales.cldr.data.numericsystems._"))) ++ objectBlock
    ) inPackage "locales.cldr.data"
  }

  def findParent(root: XMLLDML, langs: List[List[String]],
                 ldml: XMLLDML, parentLocales: Map[String, List[String]]): Option[String] = {
    // http://www.unicode.org/reports/tr35/#Locale_Inheritance
    parentLocales.find(_._2.contains(ldml.fileName)).fold(
      // This searches based on the simple hierarchy resolution based on bundle_name
      // http://www.unicode.org/reports/tr35/#Bundle_vs_Item_Lookup
      ldml.scalaSafeName.split("_").reverse.toList match {
        case x :: Nil if x == root.scalaSafeName => None
        case x :: Nil => Some(root.scalaSafeName)
        case x :: xs if langs.contains(xs.reverse) => Some(xs.reverse.mkString("_"))
      }
    )(p => Some(p._1))
  }

  def buildClassTree(root: XMLLDML, langs: List[List[String]], parentLocales: Map[String, List[String]])
                    (ldml: XMLLDML): Tree = {
    val ldmlSym = getModule("LDML")
    val ldmlNumericSym = getModule("Symbols")
    val ldmlNumberCurrency = getModule("NumberCurrency")
    val ldmlCurrencySym = getModule("CurrencySymbol")
    val ldmlCurrencyDisplayName = getModule("CurrencyDisplayName")
    val ldmlCalendarSym = getModule("CalendarSymbols")
    val ldmlCalendarPatternsSym = getModule("CalendarPatterns")
    val ldmlLocaleSym = getModule("LDMLLocale")

    val parent = findParent(root, langs, ldml, parentLocales).fold(NONE)(v => SOME(REF(v)))

    val ldmlLocaleTree = Apply(ldmlLocaleSym, LIT(ldml.locale.language),
      ldml.locale.territory.fold(NONE)(t => SOME(LIT(t))),
      ldml.locale.variant.fold(NONE)(v => SOME(LIT(v))),
      ldml.locale.script.fold(NONE)(s => SOME(LIT(s))))

    val defaultNS = ldml.defaultNS.fold(NONE)(s => SOME(REF(s.id)))

    // Locales only use the default numeric system
    val numericSymbols = ldml.digitSymbols.map { case (ns, symb) =>
      val decimal = symb.decimal.fold(NONE)(s => SOME(LIT(s)))
      val group = symb.group.fold(NONE)(s => SOME(LIT(s)))
      val list = symb.list.fold(NONE)(s => SOME(LIT(s)))
      val percent = symb.percent.fold(NONE)(s => SOME(LIT(s)))
      val minus = symb.minus.fold(NONE)(s => SOME(LIT(s)))
      val perMille = symb.perMille.fold(NONE)(s => SOME(LIT(s)))
      val infinity = symb.infinity.fold(NONE)(s => SOME(LIT(s)))
      val nan = symb.nan.fold(NONE)(s => SOME(LIT(s)))
      val exp = symb.exp.fold(NONE)(s => SOME(LIT(s)))
      Apply(ldmlNumericSym, REF(ns.id),
        symb.aliasOf.fold(NONE)(n => SOME(REF(n.id))), decimal, group, list,
        percent, minus, perMille, infinity, nan, exp)
    }

    val currencies = ldml.currencies.map{ c =>
      val symbols = LIST(c.symbols.map{ s =>
        Apply(ldmlCurrencySym, LIT(s.symbol), LITOPTION(s.alt))
      })

      val displayNames = LIST(c.displayNames.map{ n =>
        Apply(ldmlCurrencyDisplayName, LIT(n.name), LITOPTION(n.count))
      })

      Apply(ldmlNumberCurrency, LIT(c.currencyCode), symbols, displayNames)
    }

    val gc = ldml.calendar.map { cs =>
      Apply(ldmlCalendarSym, LIST(cs.months.months.map(LIT(_))), LIST(cs.months.shortMonths.map(LIT(_))),
        LIST(cs.weekdays.weekdays.map(LIT(_))), LIST(cs.weekdays.shortWeekdays.map(LIT(_))),
        LIST(cs.amPm.amPm.map(LIT(_))), LIST(cs.eras.eras.map(LIT(_))))
    }.fold(NONE)(s => SOME(s))

    val gcp = ldml.datePatterns.map { cs =>
      def patternToIndex(i: String) = i match {
        case "full" => 0
        case "long" => 1
        case "medium" => 2
        case "short" => 3
        case x => throw new IllegalArgumentException(s"Unknown format $x, abort ")
      }

      val dates = MAKE_MAP(cs.datePatterns.map(p => TUPLE(LIT(patternToIndex(p.patternType)), LIT(p.pattern))))
      val times = MAKE_MAP(cs.timePatterns.map(p => TUPLE(LIT(patternToIndex(p.patternType)), LIT(p.pattern))))
      Apply(ldmlCalendarPatternsSym, dates, times)
    }.fold(NONE)(s => SOME(s))

    OBJECTDEF(ldml.scalaSafeName) withParents Apply(ldmlSym, parent,
      ldmlLocaleTree, defaultNS, LIST(numericSymbols), gc, gcp, LIST(currencies))
  }

  def metadata(codes: List[String], languages: List[String], scripts: List[String]): Tree = {
    BLOCK (
      OBJECTDEF("metadata") := BLOCK(
        LAZYVAL("isoCountries", "Array[String]") :=
          ARRAY(codes.map(LIT(_))) withComment autoGeneratedCommend,
        LAZYVAL("isoLanguages", "Array[String]") :=
          ARRAY(languages.map(LIT(_))) withComment autoGeneratedCommend,
        LAZYVAL("scripts", "Array[String]") :=
          ARRAY(scripts.map(LIT(_))) withComment autoGeneratedCommend
      )
    ) inPackage "locales.cldr.data"
  }

  def numericSystems(ns: Seq[NumericSystem]): Tree = {
    val ldmlNS = getModule("NumberingSystem")

    BLOCK (
      IMPORT(REF("locales.cldr.NumberingSystem")) withComment autoGeneratedCommend,
      OBJECTDEF("numericsystems") := BLOCK(
        ns.map(s =>
          LAZYVAL(s.id, "NumberingSystem") :=
            Apply(ldmlNS, LIT(s.id), LIST(s.digits.toList.map(LIT(_))))
        )
      )
    ) inPackage "locales.cldr.data"
  }

  def calendars(c: Seq[Calendar]): Tree = {
    val ldmlNS = getModule("Calendar")

    BLOCK (
      IMPORT(REF("locales.cldr.Calendar")) withComment autoGeneratedCommend,
      OBJECTDEF("calendars") := BLOCK(
        (LAZYVAL("all", "List[Calendar]") := LIST(c.map(c => REF(c.scalaSafeName)))) +:
          c.map(c =>
            LAZYVAL(c.scalaSafeName, "Calendar") :=
              Apply(ldmlNS, LIT(c.id))
          )
      )
    ) inPackage "scala.scalajs.locale.cldr.data"
  }

  // Take an Option("foo") and generate the SOME(LIT("FOO"))
  private def LITOPTION(o: Option[_]): Tree = o.fold(NONE)(v => SOME(LIT(v)))

  //private def DATEOPTION(o: Option[Date]): Tree = o.fold(NONE)(v => SOME(NEW("Date", LIT(v.getTime))))

  def currencyData(c: CurrencyData): Tree = {
    BLOCK (
      IMPORT(REF("locales.cldr._")) withComment autoGeneratedCommend,
      OBJECTDEF("currencydata") := BLOCK(
        VAL("currencyTypes", "List[CurrencyType]") := LIST(c.currencyTypes.map{ code: CurrencyType =>
          REF("CurrencyType") APPLY (
            LIT(code.currencyCode),
            LIT(code.currencyName)
            )
        }),
        VAL("fractions", "List[CurrencyDataFractionsInfo]") := LIST(c.fractions.map{ info: CurrencyDataFractionsInfo =>
          REF("CurrencyDataFractionsInfo") APPLY (
            LIT(info.currencyCode),
            LIT(info.digits),
            LIT(info.rounding),
            LITOPTION(info.cashDigits),
            LITOPTION(info.cashRounding)
            )
        }),
        VAL("regions", "List[CurrencyDataRegion]") := LIST(c.regions.map{ region: CurrencyDataRegion =>
          REF("CurrencyDataRegion") APPLY (
            LIT(region.countryCode),
            LIST(region.currencies.map{ currency: CurrencyDataRegionCurrency =>
              REF("CurrencyDataRegionCurrency") APPLY (
                LIT(currency.currencyCode),
                LITOPTION(currency.from), //DATEOPTION(currency.from),
                LITOPTION(currency.to), // DATEOPTION(currency.to),
                LITOPTION(currency.tender)
                )
            })
            )
        }),
        VAL("numericCodes", "List[CurrencyNumericCode]") := LIST(c.numericCodes.map{ code: CurrencyNumericCode =>
          REF("CurrencyNumericCode") APPLY (
            LIT(code.currencyCode),
            LIT(code.numericCode)
            )
        })
      )
    ) inPackage "locales.cldr.data"
  }
}

object ScalaLocaleCodeGen {
  def writeGeneratedTree(base: File, file: String, tree: treehugger.forest.Tree):File = {
    val dataPath = base.toPath.resolve("locales").resolve("cldr").resolve("data")
    val path = dataPath.resolve(s"$file.scala")

    path.getParent.toFile.mkdirs()
    println(s"Write to $path")

    Files.write(path, treehugger.forest.treeToString(tree)
      .getBytes(Charset.forName("UTF8")))
    path.toFile
  }

  val unicodeIgnorable = new IntPredicate {
    override def test(value: Int): Boolean = !Character.isIdentifierIgnorable(value)
  }

  def readCalendarData(xml: Node): Option[CalendarSymbols] = {
    def readEntries(mc: Node, itemParent: String, entryName: String, width: String): Seq[String] =
      for {
        w <- mc \ itemParent
        if (w \ "@type").text == width
        m <- w \\ entryName
      } yield m.text

    // read the months context
    val months = (for {
      mc <- xml \\ "monthContext"
      if (mc \ "@type").text == "format"
    } yield {
      val wideMonths = readEntries(mc, "monthWidth", "month", "wide")
      val shortMonths = readEntries(mc, "monthWidth", "month", "abbreviated")
      MonthSymbols(wideMonths, shortMonths)
    }).headOption

    // read the weekdays context
    val weekdays = (for {
      mc <- xml \\ "dayContext"
      if (mc \ "@type").text == "format"
    } yield {
      val weekdays = readEntries(mc, "dayWidth", "day", "wide")
      val shortWeekdays = readEntries(mc, "dayWidth", "day", "abbreviated")
      WeekdaysSymbols(weekdays, shortWeekdays)
    }).headOption

    def readPeriod(n: Node, name: String): Option[String] =
      (for {
        p <- n \ "dayPeriod"
        if (p \ "@type").text == name && (p \ "@alt").text != "variant"
      } yield p.text).headOption

    // read the day periods
    val amPm = (for {
      dpc <- xml \\ "dayPeriods" \ "dayPeriodContext"
      if (dpc \ "@type").text == "format"
      dpw <- dpc \\ "dayPeriodWidth"
      if (dpw \ "@type").text == "wide"
    } yield {
      val am = readPeriod(dpw, "am")
      val pm = readPeriod(dpw, "pm")
      // This is valid because by the spec am and pm must appear together
      // http://www.unicode.org/reports/tr35/tr35-dates.html#Day_Period_Rules
      AmPmSymbols(List(am, pm).flatten)
    }).headOption

    def readEras(n: Node, idx: String): Option[String] =  {
      (for {
        p <- n \ "eraAbbr" \\ "era"
        if (p \ "@type").text == idx && (p \ "@alt").text != "variant"
      } yield p.text).headOption
    }

    val eras = (for {
      n <- xml \ "eras"
    } yield {
      val bc = readEras(n, "0")
      val ad = readEras(n, "1")
      EraSymbols(List(bc, ad).flatten)
    }).headOption

    if (List(months, weekdays, amPm, eras).exists(_.isDefined)) {
      Some(CalendarSymbols(months.getOrElse(MonthSymbols.zero),
        weekdays.getOrElse(WeekdaysSymbols.zero), amPm.getOrElse(AmPmSymbols.zero),
        eras.getOrElse(EraSymbols.zero)))
    } else {
      None
    }
  }

  def readCalendarPatterns(xml: Node): Option[CalendarPatterns] = {
    def readPatterns(n: Node, sub: String, formatType: String): Seq[DateTimePattern] =
      for {
        ft <- n \ formatType
        p <- ft \ sub \ "pattern"
        if (p \ "@alt").text != "variant"
      } yield DateTimePattern((ft \ "@type").text, p.text)

    val datePatterns = (for {
      df <- xml \\ "dateFormats"
    } yield {
      readPatterns(df, "dateFormat", "dateFormatLength")
    }).headOption.map(_.toList)

    val timePatterns = (for {
      df <- xml \\ "timeFormats"
    } yield {
      readPatterns(df, "timeFormat", "timeFormatLength")
    }).headOption.map(_.toList)

    Some(CalendarPatterns(datePatterns.getOrElse(Nil), timePatterns.getOrElse(Nil)))
  }

  // Pass in currency types into this, so we can augment the CurrencyData to include the master code list
  def parseCurrencyData(xml: Node, currencyTypes: Seq[CurrencyType]): CurrencyData = {
    def toOptionInt(node: NodeSeq): Option[Int] =
      if (node.nonEmpty && node.text.trim.nonEmpty) Some(node.text.trim.toInt) else None
    def toOptionDate(node: NodeSeq): Option[String] = {
      if (node.nonEmpty && node.text.trim.nonEmpty) Some(node.text.trim) /*Some(sdf.parse(node.text.trim))*/ else None
    }

    def toOptionBoolean(node: NodeSeq): Option[Boolean] =
      if (node.nonEmpty && node.text.trim.nonEmpty) Some(node.text.trim.toBoolean) else None

    // Lookup the currencyCode => numericCode mappings first so we can augment the fractions info
    val numericCodes = (for {
      codes <- xml \ "codeMappings" \\ "currencyCodes"
    } yield {
      CurrencyNumericCode((codes \ "@type").text.toUpperCase, (codes \ "@numeric").text.toInt)
    })

    val fractions = (for {
      info <- xml \ "currencyData" \ "fractions" \\ "info"
    } yield {
      val currencyCode = (info \ "@iso4217").text.toUpperCase
      val digits = (info \ "@digits").text.toInt
      val rounding = (info \ "@rounding").text.toInt
      val cashDigits = toOptionInt(info \ "@cashDigits")
      val cashRounding = toOptionInt(info \ "@cashRounding")
      CurrencyDataFractionsInfo(
        currencyCode,
        digits,
        rounding,
        cashDigits,
        cashRounding
      )
    })

    val regions = (for {
      region <- xml \ "currencyData" \\ "region"
      currency <- region \\ "currency"
    } yield {
      val countryCode = (region \ "@iso3166").text

      val currencyCode = (currency \ "@iso4217").text
      // TODO: why am I getting random compile errors on these two fields?
      val from = toOptionDate((currency \ "@from"))
      val to = toOptionDate((currency \ "@to"))
      val tender = toOptionBoolean((currency \ "@tender"))

      countryCode -> CurrencyDataRegionCurrency(currencyCode, from, to, tender)
    }).groupBy{ _._1 }.map{ case (countryCode: String, currencies: Seq[(String, CurrencyDataRegionCurrency)]) =>
      CurrencyDataRegion(countryCode, currencies.map{ _._2 })
    }.toSeq

    CurrencyData(currencyTypes = currencyTypes, fractions = fractions, regions = regions, numericCodes = numericCodes)
  }

  def parseCurrencyTypes(xml: Node): Seq[CurrencyType] = {
    (for {
      keys <- (xml \ "keyword" \ """key""")
      currencyKeys <- keys.filter{ n => (n \ "@name").text == "cu" }
      currencyType <- (currencyKeys \\ "type")
    } yield {
      CurrencyType((currencyType \ "@name").text.toUpperCase, (currencyType \ "@description").text)
    })
  }

  /**
   * Parse the xml into an XMLLDML object
   */
  def constructLDMLDescriptor(f: File, xml: Elem, latn: NumericSystem,
                              ns: Map[String, NumericSystem]): XMLLDML = {
    // Parse locale components
    val language = (xml \ "identity" \ "language" \ "@type").text
    val territory = Option((xml \ "identity" \ "territory" \ "@type").text)
      .filter(_.nonEmpty)
    val variant = Option((xml \ "identity" \ "variant" \ "@type").text)
      .filter(_.nonEmpty)
    val script = Option((xml \ "identity" \ "script" \ "@type").text)
      .filter(_.nonEmpty)

    val gregorian = for {
      n <- xml \ "dates" \\ "calendar"
      if (n \ "@type").text == "gregorian"
      if n.text.nonEmpty
    } yield readCalendarData(n)

    val gregorianDatePatterns = for {
      n <- xml \ "dates" \\ "calendar"
      if (n \ "@type").text == "gregorian"
      if n.text.nonEmpty
    } yield readCalendarPatterns(n)

    // Find out the default numeric system
    val defaultNS = Option((xml \ "numbers" \ "defaultNumberingSystem").text)
      .filter(_.nonEmpty).filter(ns.contains)
    def optionalString(n: NodeSeq): Option[String] = if (n.isEmpty) None else Some(n.text)

    def symbolC(n: NodeSeq): Option[Char] = if (n.isEmpty) None else {
      // Filter out the ignorable code points, e.g. RTL and LTR marks
      val charInt = n.text.codePoints().filter(unicodeIgnorable).findFirst().orElse(0)
      Some(charInt.toChar)
    }

    val symbols = (xml \ "numbers" \\ "symbols").flatMap { s =>
      // http://www.unicode.org/reports/tr35/tr35-numbers.html#Numbering_Systems
      // By default, number symbols without a specific numberSystem attribute
      // are assumed to be used for the "latn" numbering system, which i
      // western (ASCII) digits
      val nsAttr = Option((s \ "@numberSystem").text).filter(_.nonEmpty)
      val sns = nsAttr.flatMap(ns.get).getOrElse(latn)
      // TODO process aliases
      val nsSymbols = s.collect {
        case s @ <symbols>{_*}</symbols> if (s \ "alias").isEmpty =>
          // elements may not be present and they could be the empty string
          val decimal = symbolC(s \ "decimal")
          val group = symbolC(s \ "group")
          val list = symbolC(s \ "list")
          val percentSymbol = symbolC(s \ "percentSign")
          val plusSign = symbolC(s \ "plusSign")
          val minusSign = symbolC(s \ "minusSign")
          val perMilleSign = symbolC(s \ "perMille")
          val infiniteSign = optionalString(s \ "infinity")
          val nan = optionalString(s \ "nan")
          val exp = optionalString(s \ "exponential")
          val sym = NumberSymbols(sns, None, decimal, group, list,
            percentSymbol, plusSign, minusSign, perMilleSign, infiniteSign, nan, exp)
          sns -> sym

        case s @ <symbols>{_*}</symbols> =>
          // We take advantage that all aliases on CLDR are to latn
          sns -> NumberSymbols.alias(sns, latn)
      }
      nsSymbols
    }

    val currencies = (xml \ "numbers" \ "currencies" \\ "currency").map { c =>
      val currencyCode = (c \ "@type").text
      val symbols = (c \\ "symbol").map { s =>
        CurrencySymbol(s.text, optionalString(s \ "@alt"))
      }
      val displayNames = (c \\ "displayName").map { n =>
        CurrencyDisplayName(n.text, optionalString(n \ "@count"))
      }

      NumberCurrency(currencyCode, symbols, displayNames)
    }

    val fileName = f.getName.substring(0, f.getName.lastIndexOf("."))

    XMLLDML(XMLLDMLLocale(language, territory, variant, script), fileName,
      defaultNS.flatMap(ns.get), symbols.toMap, gregorian.flatten.headOption, gregorianDatePatterns.flatten.headOption, currencies)
  }

  // Note this must be a def or there could be issues with concurrency
  def parser: SAXParser = {
    val f = SAXParserFactory.newInstance()
    // Don't validate to speed up generation
    f.setNamespaceAware(false)
    f.setValidating(false)
    f.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    f.newSAXParser()
  }

  def parseNumberingSystems(xml: Elem): Seq[NumericSystem] = {
    val ns = xml \ "numberingSystems" \\ "numberingSystem"

    for {
      n <- ns
      if (n \ "@type").text == "numeric" // ignore algorithmic ns
    } yield {
      val id = (n \ "@id").text
      val digits = (n \ "@digits").text
      NumericSystem(id, digits)
    }
  }

  def readNumericSystems(data: File): Seq[NumericSystem] = {
    // Parse the numeric systems
    val numberingSystemsFile = data.toPath.resolve("common")
      .resolve("supplemental").resolve("numberingSystems.xml").toFile
    parseNumberingSystems(XML.withSAXParser(parser).loadFile(numberingSystemsFile))
  }

  def generateNumericSystemsFile(base: File, numericSystems: Seq[NumericSystem]): File = {
    // Generate numeric systems source code
    writeGeneratedTree(base, "numericsystems",
      CodeGenerator.numericSystems(numericSystems))
  }

  def parseCalendars(xml: Elem): Seq[Calendar] = {
    val ns = xml \ "calendarData" \\ "calendar"

    for {
      n <- ns
    } yield {
      val id = (n \ "@type").text
      Calendar(id)
    }
  }

  def readCalendars(data: File): Seq[Calendar] = {
    // Parse the numeric systems
    val calendarsSupplementalData = data.toPath.resolve("common")
      .resolve("supplemental").resolve("supplementalData.xml").toFile
    parseCalendars(XML.withSAXParser(parser).loadFile(calendarsSupplementalData))
  }

  // Let's augment the "CurrencyData" in supplemental data with the master bcp47 type list
  def readCurrencyData(data: File): CurrencyData = {
    val currencySupplementalData = data.toPath.resolve("common")
      .resolve("supplemental").resolve("supplementalData.xml").toFile
    parseCurrencyData(XML.withSAXParser(parser).loadFile(currencySupplementalData), readCurrencyTypes(data))
  }

  def readCurrencyTypes(data: File): Seq[CurrencyType] = {
    val currencyTypesData = data.toPath.resolve("common")
      .resolve("bcp47").resolve("currency.xml").toFile
    parseCurrencyTypes(XML.withSAXParser(parser).loadFile(currencyTypesData))
  }

  def parseParentLocales(xml: Elem): Map[String, List[String]] = {
    val ns = xml \ "parentLocales" \\ "parentLocale"

    val p = for {
      n <- ns
    } yield {
      val parent = (n \ "@parent").text
      val locales = (n \ "@locales").text
      parent -> locales.split("\\s").toList
    }
    p.toMap
  }

  def readParentLocales(data: File): Map[String, List[String]] = {
    // Parse the parent locales
    val parentLocalesSupplementalData = data.toPath.resolve("common")
      .resolve("supplemental").resolve("supplementalData.xml").toFile
    parseParentLocales(XML.withSAXParser(parser).loadFile(parentLocalesSupplementalData))
  }

  def generateCalendarsFile(base: File, calendars: Seq[Calendar]): File = {
    // Generate numeric systems source code
    writeGeneratedTree(base, "calendars",
      CodeGenerator.calendars(calendars))
  }

  def buildLDMLDescriptors(data: File, numericSystemsMap: Map[String, NumericSystem],
                           latnNS: NumericSystem): List[XMLLDML] = {
    // All files under common/main
    val files = Files.newDirectoryStream(data.toPath.resolve("common")
      .resolve("main")).iterator().asScala.toList

    for {
      f <- files.map(k => k.toFile)
      //if f.getName == "en.xml" || f.getName == "root.xml"
      r = new InputStreamReader(new FileInputStream(f), "UTF-8")
    } yield constructLDMLDescriptor(f, XML.withSAXParser(parser).load(r),
      latnNS, numericSystemsMap)
  }

  def generateLocalesFile(base: File, clazzes: List[XMLLDML], parentLocales: Map[String, List[String]]): File = {
    val names = clazzes.map(_.scalaSafeName)

    // Generate locales code
    val stdTree = CodeGenerator.buildClassTree("data", clazzes, names, parentLocales)
    writeGeneratedTree(base, "data", stdTree)
  }

  def generateMetadataFile(base: File, clazzes: List[XMLLDML]): File = {
    val isoCountryCodes = clazzes.flatMap(_.locale.territory).distinct
      .filter(_.length == 2).sorted
    val isoLanguages = clazzes.map(_.locale.language).distinct
      .filter(_.length == 2).sorted
    val scripts = clazzes.flatMap(_.locale.script).distinct.sorted
    // Generate metadata source code
    writeGeneratedTree(base, "metadata",
      CodeGenerator.metadata(isoCountryCodes, isoLanguages, scripts))
  }

  def generateCurrencyDataFile(base: File, currencyData: CurrencyData): File = {
    writeGeneratedTree(base, "currencydata",
      CodeGenerator.currencyData(currencyData))
  }

  def generateDataSourceCode(base: File, data: File): Seq[File] = {
    val nanos = System.nanoTime()
    val numericSystems = readNumericSystems(data)
    val f1 = generateNumericSystemsFile(base, numericSystems)

    val calendars = readCalendars(data)
    val parentLocales = readParentLocales(data)
    val f2 = generateCalendarsFile(base, calendars)

    val numericSystemsMap: Map[String, NumericSystem] =
      numericSystems.map(n => n.id -> n)(breakOut)
    // latn NS must exist, break if not found
    val latnNS = numericSystemsMap("latn")

    val ldmls = buildLDMLDescriptors(data, numericSystemsMap, latnNS)

    val f3 = generateMetadataFile(base, ldmls)
    val f4 = generateLocalesFile(base, ldmls, parentLocales)

    val currencyData = readCurrencyData(data)
    val f5 = generateCurrencyDataFile(base, currencyData)

    println("Generation took " + (System.nanoTime() - nanos) / 1000000 + " [ms]")
    Seq(f1, f2, f3, f4, f5)
  }
}
